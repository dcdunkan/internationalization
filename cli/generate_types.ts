import { extname, log, resolve, VERSION, yellow } from "./deps.ts";
import { exists } from "jsr:@std/fs@^1/exists";
import { parseArgs } from "jsr:@std/cli@^1/parse-args";

import generateFluentTypes from "./generate_types_fluent.ts";

const OUTPUT_PREFIX = `\
// This file is auto-generated by grammY i18n CLI ${VERSION}
// Changes made to this file will be overwritten.\n\n`;

type FormatTypeGenerator = {
    extension: string;
    generate: (sources: Set<string>) => string | Promise<string>;
};

const FORMAT_TYPE_GENERATORS: Record<string, FormatTypeGenerator> = {
    "fluent": {
        extension: ".ftl",
        generate: generateFluentTypes,
    },
};

export default async function (subcommandArgs: string[]) {
    const { _: _pathArgs, ...args } = parseArgs(subcommandArgs, {
        boolean: ["watch", "quiet"],
        string: ["output", "format"],
        alias: {
            "o": "output",
        },
    });

    const pathArgs = _pathArgs.map((arg) => arg.toString());

    if (args.output == null || args.output.trim().length === 0) {
        log.error("Specify the --output file.");
        Deno.exit(1);
    }
    if (
        pathArgs.length === 0 ||
        pathArgs.every((arg) => arg.trim().length === 0)
    ) {
        log.error("Specify at least one file/directory path to watch.");
        Deno.exit(1);
    }
    if (args.format == null || args.format.trim().length === 0) {
        log.error("Specify a format for generating the types.");
        Deno.exit(1);
    }
    if (!(args.format in FORMAT_TYPE_GENERATORS)) {
        log.error(
            `Invalid format: ${args.format}. Supported formats: ` +
                Object.keys(FORMAT_TYPE_GENERATORS).join(", "),
        );
        Deno.exit(1);
    }

    const {
        extension,
        generate,
    } = FORMAT_TYPE_GENERATORS[args.format];
    const files = new Set<string>();
    const filepaths: string[] = [];

    for (const arg of pathArgs) {
        const resolved = await resolvePathArgument(arg);
        log.info(
            yellow(args.watch ? `watching` : `reading`),
            resolved.path,
        );
        for (const file of await getFiles(resolved.path, extension)) {
            files.add(file);
        }
        filepaths.push(resolved.path);
    }

    log.info("generating types");
    const output = OUTPUT_PREFIX + await generate(files);
    await Deno.writeTextFile(args.output, output);
    log.info(`updated output file ${resolve(args.output)}`);

    if (!args.watch) Deno.exit(0);

    const watcher = Deno.watchFs(filepaths, { recursive: true });
    Deno.addSignalListener("SIGINT", () => {
        log.info("closing the file watcher");
        watcher.close();
    });

    for await (const event of watcher) {
        const filepath = event.paths[0];

        // only listen to the events that affects .ftl files.
        if (event.paths.length !== 1 || extname(filepath) !== extension) {
            continue;
        }
        if (
            event.kind !== "create" && event.kind !== "modify" &&
            event.kind !== "remove"
        ) continue;

        switch (event.kind) {
            case "create": {
                if (files.has(filepath)) continue;
                const info = await Deno.stat(filepath);
                if (info.isFile) {
                    files.add(filepath);
                    log.info(yellow(`watching`), filepath);
                } else {
                    continue;
                }
                break;
            }
            case "modify":
                if (
                    await exists(filepath, { isFile: true }) &&
                    !files.has(filepath)
                ) {
                    files.add(filepath);
                    log.info(yellow(`watching`), filepath);
                }
                break;
            case "remove":
                if (!files.has(filepath)) continue;
                files.delete(filepath);
                log.info(yellow(`stopped watching`), filepath);
                break;
        }

        log.info("regenerating types");
        const output = OUTPUT_PREFIX + await generate(files);
        await Deno.writeTextFile(args.output, output);
        log.info(`updated output file ${resolve(args.output)}`);
    }
}

async function getFiles(
    source: string,
    extension: string,
): Promise<string[]> {
    // ignore dot files
    if (source.startsWith(".")) return [];
    const info = await Deno.lstat(source);
    if (info.isFile) {
        if (extname(source) !== extension) return [];
        return [resolve(source)];
    } else if (info.isDirectory) {
        const files: string[] = [];
        for await (const entry of Deno.readDir(source)) {
            const path = resolve(source, entry.name);
            const inside = await getFiles(path, extension);
            files.push(...inside);
        }
        return files;
    } else if (info.isSymlink) {
        const realpath = await Deno.realPath(source);
        return await getFiles(realpath, extension);
    } else {
        log.error(`not file, directory, or symlink.`);
        return [];
    }
}

async function resolvePathArgument(
    arg: string,
): Promise<{ path: string; dir: boolean }> {
    const file = await Deno.lstat(arg);
    if (file.isFile || file.isDirectory) {
        return { path: resolve(arg), dir: file.isDirectory };
    } else if (file.isSymlink) {
        const resolved = await Deno.readLink(arg);
        return resolvePathArgument(resolved);
    } else {
        console.error(`'${arg}' is not a file, directory, or symlink.`);
        Deno.exit(1);
    }
}
