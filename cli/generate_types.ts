import { yellow } from "jsr:@std/fmt@^1/colors";
import { parseArgs } from "jsr:@std/cli@^1/parse-args";
import {
    basename,
    dirname,
    extname,
    isAbsolute,
    join,
    relative,
    resolve,
    SEPARATOR,
} from "jsr:@std/path@^1";
import { log, makeIndent, VERSION } from "./deps.ts";
import { isValidLocale, walkResourceDirectory } from "../utilities.ts";

import generateFluentTypes from "./generate_types_fluent.ts";

const OUTPUT_PREFIX = `\
// This file is auto-generated by grammY i18n CLI ${VERSION}
// Changes made to this file will be overwritten.`;

type MaybePromise<T> = T | Promise<T>;

type FormatTypeGenerator = {
    extension: string;
    generate: (
        sources: Set<string>,
    ) => MaybePromise<{
        messages: Record<string, Record<string, string>>;
        additional: string | null;
    }>;
};

const FORMAT_TYPE_GENERATORS: Record<string, FormatTypeGenerator> = {
    "fluent": {
        extension: ".ftl",
        generate: generateFluentTypes,
    },
};

function isValidString(str: string | undefined): str is string {
    return str != null && str.trim().length > 0;
}

export default async function (subcommandArgs: string[]) {
    const { _: _pathArgs, ...args } = parseArgs(subcommandArgs, {
        boolean: ["watch", "quiet", "follow-symlinks", "ignore-dot-files"],
        string: ["output", "format", "fallback", "locales-dir"],
        alias: {
            "o": "output",
        },
        negatable: ["follow-symlinks", "ignore-dot-files"],
        default: {
            "ignore-dot-files": true,
            "follow-symlinks": false,
            watch: false,
            quiet: false,
        },
    });

    const pathArgs = _pathArgs.map((arg) => arg.toString());

    let localesDirMode = false;

    if (isValidString(args["locales-dir"])) {
        if (isValidString(args.fallback)) {
            localesDirMode = true;
            if (pathArgs.length > 0) {
                log.info(
                    "Path arguments and --locales-dir cannot be used together. Ignoring path arguments...",
                );
                pathArgs.splice(0, pathArgs.length);
            }
        } else {
            log.error(
                "--fallback must be specified when --locale-dir is used.",
            );
            Deno.exit(1);
        }
    } else if (isValidString(args.fallback)) {
        log.error("--locales-dir must be specified when --fallback is used.");
        Deno.exit(1);
    } else if (
        pathArgs.length === 0 ||
        pathArgs.every((arg) => !isValidString(arg))
    ) {
        log.error("Specify at least one file/directory path to read from.");
        Deno.exit(1);
    }

    if (!isValidString(args.output)) {
        log.error("Specify the --output file.");
        Deno.exit(1);
    }
    if (!isValidString(args.format)) {
        log.error("Specify a format for generating the types.");
        Deno.exit(1);
    }
    if (!(args.format in FORMAT_TYPE_GENERATORS)) {
        log.error(
            `Invalid format: ${args.format}. Supported formats: ` +
                Object.keys(FORMAT_TYPE_GENERATORS).join(", "),
        );
        Deno.exit(1);
    }

    const {
        extension,
        generate,
    } = FORMAT_TYPE_GENERATORS[args.format];
    const sources = new Set<string>();

    const watchpaths: string[] = [];

    const locales = new Set<string>();
    if (localesDirMode) {
        const localesDir = await resolvePath(
            args["locales-dir"]!,
            args["follow-symlinks"],
        );
        if (!localesDir.dir) {
            log.error("--locales-dir is not a directory");
            Deno.exit(1);
        }
        for await (const dirent of await Deno.readDir(localesDir.path)) {
            if (dirent.isDirectory) {
                locales.add(dirent.name);
                continue;
            } else if (dirent.isFile && extname(dirent.name) === extension) {
                const filepath = resolve(localesDir.path, dirent.name);
                sources.add(filepath);
            } else if (dirent.isSymlink) {
                // todo: if directory, watch the realpath, else: source the file
            }
        }
        if (!locales.has(args.fallback!)) {
            log.error("Could not find --fallback inside --locales-dir");
            Deno.exit(1);
        }

        log.info(
            yellow(args.watch ? `watching` : `reading`),
            localesDir.path,
            "files and files inside ",
            join(localesDir.path, args.fallback!),
        );

        for await (
            const file of walkResourceDirectory(
                join(localesDir.path, args.fallback!),
                extension,
                {
                    followSymlinks: args["follow-symlinks"],
                    ignoreDotFiles: args["ignore-dot-files"],
                },
            )
        ) {
            sources.add(file);
        }

        watchpaths.push(localesDir.path);
    } else {
        for (const arg of pathArgs) {
            const resolved = await resolvePath(arg, args["follow-symlinks"]);
            log.info(
                yellow(args.watch ? `watching` : `reading`),
                resolved.path,
            );
            for await (
                const file of walkResourceDirectory(
                    resolved.path,
                    extension,
                    {
                        followSymlinks: args["follow-symlinks"],
                        ignoreDotFiles: args["ignore-dot-files"],
                    },
                )
            ) {
                sources.add(file);
            }
            watchpaths.push(resolved.path);
        }
    }

    await writeGenerated(locales, await generate(sources), args.output);
    if (!args.watch) Deno.exit(0);

    log.info("starting file watcher");

    const watcher = Deno.watchFs(watchpaths, { recursive: true });
    Deno.addSignalListener("SIGINT", () => {
        log.info("closing the file watcher");
        watcher.close();
    });

    const localesDir = args["locales-dir"]
        ? resolve(args["locales-dir"]!)
        : undefined;

    for await (const event of watcher) {
        const filepath = event.paths[0];

        if (event.paths.length !== 1) continue;
        if (
            event.kind !== "create" && event.kind !== "modify" &&
            event.kind !== "remove"
        ) continue;

        if (localesDirMode && dirname(filepath) === localesDir!) {
            const localeName = basename(filepath);
            try {
                const stat = await Deno.stat(
                    args["follow-symlinks"]
                        ? await Deno.realPath(filepath)
                        : filepath,
                );

                if (stat.isDirectory) {
                    if (isValidLocale(localeName)) {
                        locales.add(localeName);
                        await writeGenerated(
                            locales,
                            await generate(sources),
                            args.output,
                        );
                    } else {
                        log.error(
                            "Found changes in",
                            filepath,
                            "but ignoring because the directory name seems invalid for a locale",
                        );
                    }
                }
            } catch (error) {
                if (error instanceof Deno.errors.NotFound) {
                    if (localeName === args.fallback) {
                        log.error(
                            "Fallback locale directory no longer exists. Exiting...",
                        );
                        watcher.close();
                        Deno.exit(1);
                    }
                    locales.delete(localeName);
                    await writeGenerated(
                        locales,
                        await generate(sources),
                        args.output,
                    );
                } else {
                    log.error("Some error occurred:");
                    console.error(error);
                }
            }

            continue;
        }

        if (extname(filepath) !== extension) continue;

        if (localesDirMode) {
            const parent = resolve(args["locales-dir"]!, args.fallback!);
            const relativePath = relative(filepath, parent);
            if (
                (isAbsolute(relativePath) ||
                    relativePath.split(SEPARATOR)
                        .some((part) => part !== "..")) &&
                dirname(filepath) !== resolve(args["locales-dir"]!)
            ) {
                continue;
            }
        }

        switch (event.kind) {
            case "create": {
                if (sources.has(filepath)) continue;
                const info = await Deno.stat(filepath);
                if (info.isFile) {
                    sources.add(filepath);
                    log.info(yellow(`watching`), filepath);
                } else {
                    continue;
                }
                break;
            }
            case "modify":
                if (await isFile(filepath) && !sources.has(filepath)) {
                    sources.add(filepath);
                    log.info(yellow(`watching`), filepath);
                }
                break;
            case "remove":
                if (!sources.has(filepath)) continue;
                sources.delete(filepath);
                log.info(yellow(`stopped watching`), filepath);
                break;
        }

        await writeGenerated(locales, await generate(sources), args.output);
    }
}

async function writeGenerated(
    locales: Set<string>,
    generatedOutput: {
        messages: Record<string, Record<string, string>>;
        additional: string | null;
    },
    outputFile: string,
) {
    log.info("generating types");

    const indent = makeIndent(4);

    const availableLocales: string = locales.size > 0
        ? Array.from(locales)
            .map((locale) => `"${locale}"`)
            .reduce((p, locale) => {
                if (p[p.length - 1].length === 5) return [...p, [locale]];
                p[p.length - 1].push(locale);
                return p;
            }, [[]] as string[][])
            .map((line) => line.join(" | "))
            .join(`\n${indent(1)}| `)
        : "string";

    const availableMessages: string = Object
        .entries(generatedOutput.messages)
        .map(([messageKey, variables]) => {
            const variableKeys = Object.keys(variables);
            const variableType = variableKeys.length === 0
                ? "never"
                : "{\n" + variableKeys.map((key) => {
                    return indent(2) + `"${key}": ${variables[key]};`;
                }).join("\n") + `\n${indent(1)}}`;
            return `${indent(1)}"${messageKey}": ${variableType};`;
        })
        .join("\n");

    const additionalContent = generatedOutput.additional != null
        ? ("\n" + generatedOutput.additional + "\n")
        : "";

    const output = `${OUTPUT_PREFIX}
${additionalContent}\

type AvailableLocales = ${availableLocales};

type AvailableMessages = {\n${availableMessages}\n};

export type GeneratedLocalesTypings = {
    locales: AvailableLocales;
    messages: AvailableMessages;
};\n`;

    await Deno.writeTextFile(outputFile, output);
    log.info(`written to output file ${resolve(outputFile)}`);
}

async function resolvePath(
    arg: string,
    followSymlinks: boolean,
): Promise<{ path: string; dir: boolean }> {
    const file = await Deno.lstat(arg);
    if (file.isFile || file.isDirectory) {
        return { path: resolve(arg), dir: file.isDirectory };
    } else if (file.isSymlink && followSymlinks) {
        const resolved = await Deno.readLink(arg);
        return resolvePath(resolved, followSymlinks);
    } else {
        console.error(`'${arg}' is not a file, directory, or symlink.`);
        Deno.exit(1);
    }
}

async function isFile(path: string): Promise<boolean> {
    try {
        const stat = await Deno.lstat(path);
        return stat.isFile;
    } catch (error) {
        if (error instanceof Deno.errors.NotFound) {
            return false;
        }
        throw error;
    }
}
